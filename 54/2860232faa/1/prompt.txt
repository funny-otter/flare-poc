go in trustless merkle

---

start imple task from bd, keep openspec in sync

---

<task-notification>
<task-id>aeea5cf</task-id>
<status>completed</status>
<summary>Agent "Research FdcVerification leaf encoding" completed</summary>
<result>I now have all the information needed for a comprehensive answer. Let me also quickly verify the MIC_SALT and the MIC hash relationship.

The `attestationResponseHash` function in `AttestationDefinitionStore.ts` shows:
- Without salt: `keccak256(abi.encode(responseAbi, response))` -- this is the **leaf hash** for the Merkle tree
- With salt "Flare": `keccak256(abi.encode(responseAbi, response, "string", "Flare"))` -- this is the **MIC (Message Integrity Code)**

And in `FdcVerification.sol`:
```solidity
keccak256(abi.encode(_proof.data))
```

These match because `_proof.data` is `IEVMTransaction.Response` which matches `responseAbi`.

Here is the complete research findings:

---

## Research Findings: FdcVerification Merkle Leaf Construction

### 1. Leaf Hash Formula

**The leaf hash is exactly:**

```solidity
keccak256(abi.encode(_proof.data))
```

where `_proof.data` is the **entire `IEVMTransaction.Response` struct** (everything except `merkleProof`).

This is confirmed directly in the source code at `/contracts/fdc/implementation/FdcVerification.sol` in the [flare-smart-contracts-v2](https://github.com/flare-foundation/flare-smart-contracts-v2) repository:

```solidity
function verifyEVMTransaction(IEVMTransaction.Proof calldata _proof)
    external view returns (bool _proved)
{
    bytes32 merkleRoot = relay.merkleRoots(fdcProtocolId, _proof.data.votingRound);
    return
        _proof.data.attestationType == bytes32("EVMTransaction") &&
        _proof.merkleProof.verifyCalldata(merkleRoot, keccak256(abi.encode(_proof.data)));
}
```

Key points:
- It uses **`abi.encode`** (NOT `abi.encodePacked`). This is standard ABI encoding with padding.
- The input to `keccak256` is the ABI encoding of the **entire `Response` struct** (the `_proof.data` field).
- It also checks that `attestationType == bytes32("EVMTransaction")` as a sanity guard.

### 2. Exact Struct Layout for EVMTransaction

From `/coston2/IEVMTransaction.sol` in the [flare-solidity-periphery-package-mirror](https://github.com/flare-foundation/flare-solidity-periphery-package-mirror):

```solidity
interface IEVMTransaction {
    struct Proof {
        bytes32[] merkleProof;
        Response data;        // <-- this is what gets hashed for the leaf
    }

    struct Response {
        bytes32 attestationType;      // "EVMTransaction" as bytes32
        bytes32 sourceId;             // "testETH" as bytes32 (for Coston2/Sepolia)
        uint64  votingRound;
        uint64  lowestUsedTimestamp;
        RequestBody requestBody;
        ResponseBody responseBody;
    }

    struct RequestBody {
        bytes32  transactionHash;
        uint16   requiredConfirmations;
        bool     provideInput;
        bool     listEvents;
        uint32[] logIndices;
    }

    struct ResponseBody {
        uint64   blockNumber;
        uint64   timestamp;
        address  sourceAddress;
        bool     isDeployment;
        address  receivingAddress;
        uint256  value;
        bytes    input;
        uint8    status;
        Event[]  events;
    }

    struct Event {
        uint32    logIndex;
        address   emitterAddress;
        bytes32[] topics;
        bytes     data;
        bool      removed;
    }
}
```

So the leaf is: `keccak256(abi.encode(Response))` where `Response` contains all of: `attestationType`, `sourceId`, `votingRound`, `lowestUsedTimestamp`, `requestBody` (with all its fields), and `responseBody` (with all its fields including nested `events`).

### 3. Merkle Proof Algorithm: OpenZeppelin Sorted Pairs (Commutative)

**FdcVerification uses OpenZeppelin's MerkleProof library with sorted/commutative hashing.**

From `FdcVerification.sol`:
```solidity
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

contract FdcVerification is IFdcVerification, AddressUpdatable {
    using MerkleProof for bytes32[];
    // ...
    _proof.merkleProof.verifyCalldata(merkleRoot, keccak256(abi.encode(_proof.data)));
}
```

OpenZeppelin's `verifyCalldata` calls `processProofCalldata` which uses `Hashes.commutativeKeccak256()`:
```solidity
// From OpenZeppelin Hashes.sol
function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {
    return a < b ? efficientKeccak256(a, b) : efficientKeccak256(b, a);
}
```

This means:
- **Sorted pairs**: At each level, the two sibling hashes are sorted (smaller first) before being concatenated and hashed.
- **NOT positional left/right**: You do NOT need to track whether the proof element is a left or right sibling -- the sorting handles it.
- The proof is just a flat array of `bytes32[]` sibling hashes, one per tree level.

This is also confirmed by the off-chain implementation in `/src/external-libs/ts/MerkleTree.ts` from the [evm-verifier](https://github.com/flare-foundation/evm-verifier) repo:

```typescript
export function sortedHashPair(x: string, y: string) {
    if (x <= y) {
        return ethers.keccak256(coder.encode(["bytes32", "bytes32"], [x, y]));
    }
    return ethers.keccak256(coder.encode(["bytes32", "bytes32"], [y, x]));
}
```

**Important detail about the pair hashing**: The pair hash uses `abi.encode(["bytes32", "bytes32"], [a, b])` (which produces 64 bytes of concatenated 32-byte values), NOT `abi.encodePacked`. OpenZeppelin's Solidity implementation does the equivalent using inline assembly for efficiency, but the result is the same as `keccak256(abi.encode(sorted_a, sorted_b))`.

Additionally, the off-chain MerkleTree implementation:
- **Sorts leaves** before building the tree (`sorted.sort()`)
- **Deduplicates** leaves (removes identical hashes)
- Uses a binary heap array representation (root at index 0, leaves at `[n-1 ... 2n-2]`)

### 4. Relay Contract: Where Merkle Roots are Stored

The `Relay` contract stores Merkle roots in:
```solidity
mapping(uint256 protocolId => mapping(uint256 votingRoundId => bytes32)) private merkleRootsPrivate;
```

Accessed via:
```solidity
function merkleRoots(uint256 _protocolId, uint256 _votingRoundId) external view returns (bytes32);
```

The FDC protocol has a specific `fdcProtocolId` (stored as `uint8` in FdcVerification). When verification happens:
```solidity
bytes32 merkleRoot = relay.merkleRoots(fdcProtocolId, _proof.data.votingRound);
```

The Relay also has a lower-level `verify` function that can verify arbitrary leaves:
```solidity
function verify(uint256 _protocolId, uint256 _votingRoundId, bytes32 _leaf, bytes32[] calldata _proof)
    external payable returns (bool);
```

This also uses `_proof.verifyCalldata(merkleRootsPrivate[_protocolId][_votingRoundId], _leaf)` -- the same OpenZeppelin sorted-pair verification.

### 5. Off-Chain Leaf Hash (for trustless verification)

The off-chain code in the `AttestationDefinitionStore` computes the same hash:

```typescript
// From AttestationDefinitionStore.ts
attestationResponseHash<T extends ARESBase>(response: T, salt?: string): string {
    const attestationType = decodeAttestationName(response.attestationType);
    const definition = this.getDefinitionForDecodedAttestationType(attestationType);
    let abiEncoded;
    if (salt) {
        // This is the MIC (Message Integrity Code) = keccak256(abi.encode(response, "Flare"))
        abiEncoded = this.coder.encode([definition.responseAbi, "string"], [response, salt]);
    } else {
        // This is the LEAF HASH = keccak256(abi.encode(response))
        abiEncoded = this.coder.encode([definition.responseAbi], [response]);
    }
    return ethers.keccak256(abiEncoded);
}
```

So to compute the leaf hash off-chain in TypeScript with ethers.js v6, you would do:

```typescript
const coder = ethers.AbiCoder.defaultAbiCoder();
const abiEncoded = coder.encode([responseAbiTuple], [responseData]);
const leafHash = ethers.keccak256(abiEncoded);
```

Where `responseAbiTuple` is the full ABI tuple descriptor matching `IEVMTransaction.Response`.

### Summary Table

| Aspect | Answer |
|--------|--------|
| Leaf hash | `keccak256(abi.encode(IEVMTransaction.Response))` |
| Encoding | `abi.encode` (NOT `abi.encodePacked`) |
| What gets hashed | The entire `Response` struct (= `_proof.data`), excluding `merkleProof` |
| Merkle proof type | OpenZeppelin `MerkleProof.verifyCalldata` -- **sorted pairs** (commutative) |
| Pair hashing | `keccak256(concat(min(a,b), max(a,b)))` where a,b are sibling hashes |
| Leaf ordering | Leaves are sorted and deduplicated before tree construction |
| Merkle root storage | `Relay.merkleRoots(fdcProtocolId, votingRoundId)` |
| MIC (not the leaf) | `keccak256(abi.encode(response, "Flare"))` -- used for request integrity only |</result>
<usage>total_tokens: 85354
tool_uses: 42
duration_ms: 235636</usage>
</task-notification>
Full transcript available at: /tmp/claude-1000/-home-tom-dev-oasis-flare-poc/tasks/aeea5cf.output

---

<task-notification>
<task-id>a66aa6b</task-id>
<status>completed</status>
<summary>Agent "Research Relay contract API" completed</summary>
<result>Now I have all the information. Let me compile the complete findings.

---

Here is a comprehensive summary of my research findings on the Flare Relay contract on Coston2 testnet:

## 1. Relay Contract Address on Coston2

**Address: `0x97702e350CaEda540935d92aAf213307e9069784`**

This was confirmed from two independent sources:
- The FDC client configuration file at `configs/systemConfigs/200/coston2.toml` in the [flare-foundation/fdc-client](https://github.com/flare-foundation/fdc-client) repository
- The Coston2 block explorer API at `coston2-explorer.flare.network`, which confirms the contract is a verified smart contract named **"Relay"**, deployed by `0x99E0770aa23CAA9071B6112208297E7a8d8F8a4A`

The Relay address can also be resolved dynamically at runtime by querying the **FlareContractRegistry** (same address on all Flare networks: `0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019`) with `getContractAddressByName("Relay")`.

## 2. Function Signatures for Reading Confirmed FDC Merkle Roots

The IRelay interface is defined at [`contracts/userInterfaces/IRelay.sol`](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRelay.sol) in the flare-smart-contracts-v2 repository. The key functions for reading confirmed FDC Merkle roots are:

### Primary: `merkleRoots`
```solidity
function merkleRoots(uint256 _protocolId, uint256 _votingRoundId) 
    external view returns (bytes32 _merkleRoot);
```
Returns the Merkle root for a given protocol ID and voting round ID. **Note:** This function reverts when `signingPolicySetter` is NOT set (i.e., on pure relay deployments). For the native Coston2 Relay, this should work.

### Finalization Check: `isFinalized`
```solidity
function isFinalized(uint256 _protocolId, uint256 _votingRoundId) 
    external view returns (bool);
```
Returns `true` if a finalization exists for the given protocol ID and voting round ID. This is the recommended check before attempting to read a Merkle root. The Flare developer docs specifically recommend using this for testing environments.

### On-chain Merkle Proof Verification: `verify`
```solidity
function verify(
    uint256 _protocolId, 
    uint256 _votingRoundId, 
    bytes32 _leaf, 
    bytes32[] calldata _proof
) external payable returns (bool);
```
Verifies a leaf against the stored Merkle root using a Merkle proof. This is payable -- a protocol-specific fee may be required. **Overpayment is not refunded.**

### Helper: `getVotingRoundId`
```solidity
function getVotingRoundId(uint256 _timestamp) 
    external view returns (uint256 _votingRoundId);
```
Converts a timestamp to its voting round ID. The formula is: `votingRoundId = (timestamp - 1658430000) / 90`

### Event: `ProtocolMessageRelayed`
```solidity
event ProtocolMessageRelayed(
    uint8 indexed protocolId,
    uint32 indexed votingRoundId,
    bool isSecureRandom,
    bytes32 merkleRoot
);
```
Emitted when a protocol message (including FDC Merkle roots) is relayed to the contract.

## 3. Protocol ID for FDC

**FDC Protocol ID: `200`**

This is confirmed across multiple sources:
- [Flare Developer Hub - FDC Getting Started](https://dev.flare.network/fdc/getting-started/): "Listen for the `ProtocolMessageRelayed` event with: `protocolId`: 200 (FDC protocol identifier)"
- [flare-foundation/fdc-client](https://github.com/flare-foundation/fdc-client): "currently only 200 protocol_id is supported"
- [flare-smart-contracts-v2 chain config](https://github.com/flare-foundation/flare-smart-contracts-v2): `"fdcProtocolId": 200` in `deployment/chain-config/coston2.json`
- [flare-foundation/flare-systems-deployment](https://github.com/flare-foundation/flare-systems-deployment): `"fdcProtocolId": 200` in config

For reference, the **FTSO protocol ID is `100`** (defined as `FTSO_PROTOCOL_ID = 100` in `FtsoV2.sol`).

## Complete IRelay ABI (JSON)

The full ABI is available from the npm package at [`@flarenetwork/flare-periphery-contracts`](https://www.npmjs.com/package/@flarenetwork/flare-periphery-contracts) under `coston2/artifacts/contracts/IRelay.sol/IRelay.json`. The ABI includes:

- **3 events**: `ProtocolMessageRelayed`, `SigningPolicyInitialized`, `SigningPolicyRelayed`
- **15 functions**: `feeCollectionAddress`, `getRandomNumber`, `getRandomNumberHistorical`, `getVotingRoundId`, `governanceFeeSetup`, `isFinalized`, `lastInitializedRewardEpochData`, `merkleRoots`, `protocolFeeInWei`, `relay`, `startingVotingRoundIds`, `toSigningPolicyHash`, `verify`, `verifyCustomSignature`

## Usage Pattern in TypeScript

Based on examples in `flare-foundation/fasset-bots` and `flare-foundation/developer-hub`:

```typescript
// Option 1: Resolve via FlareContractRegistry
const registryAddress = "0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019";
const relayAddress = await registry.getContractAddressByName("Relay");

// Option 2: Use known address directly
const RELAY_ADDRESS = "0x97702e350CaEda540935d92aAf213307e9069784"; // Coston2

// Check if round is finalized
const FDC_PROTOCOL_ID = 200;
const isReady = await relay.isFinalized(FDC_PROTOCOL_ID, votingRoundId);

// Read the Merkle root
const merkleRoot = await relay.merkleRoots(FDC_PROTOCOL_ID, votingRoundId);

// Convert timestamp to voting round ID
const votingRoundId = await relay.getVotingRoundId(timestamp);
// Or calculate locally: votingRoundId = (timestamp - 1658430000) / 90
```

## Other Relevant Contract Addresses on Coston2

From the fdc-client configuration:
- **FDC Contract**: `0x48aC463d7975828989331F4De43341627b9c5f1D`
- **Submit Contract**: `0x2cA6571Daa15ce734Bbd0Bf27D5C9D16787fc33f`
- **Voter Registry**: `0xc6E40401395DCc648bC4bBb38fE4552423cD9BAC`
- **FdcHub (Coston)**: `0x1c78A073E3BD2aCa4cc327d55FB0cD4f0549B55b`
- **FlareContractRegistry** (all networks): `0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019`

## Key Timing Parameters

- **Initial timestamp (t0)**: `1658430000` (Unix timestamp, July 21, 2022)
- **Voting epoch duration**: 90 seconds
- **Voting round ID formula**: `(timestamp - 1658430000) / 90`

Sources:
- [Flare Developer Hub - FDC Overview](https://dev.flare.network/fdc/overview)
- [Flare Developer Hub - FDC Getting Started](https://dev.flare.network/fdc/getting-started/)
- [Flare Developer Hub - FDC by Hand](https://dev.flare.network/fdc/guides/fdc-by-hand/)
- [flare-foundation/fdc-client](https://github.com/flare-foundation/fdc-client)
- [flare-foundation/flare-smart-contracts-v2](https://github.com/flare-foundation/flare-smart-contracts-v2) (IRelay.sol at `contracts/userInterfaces/IRelay.sol`)
- [flare-foundation/flare-npm-periphery-package](https://github.com/flare-foundation/flare-npm-periphery-package) (IRelay ABI JSON)
- [flare-foundation/developer-hub](https://github.com/flare-foundation/developer-hub) (IRelay Solidity reference docs)
- [flare-foundation/flare-solidity-periphery-package-mirror](https://github.com/flare-foundation/flare-solidity-periphery-package-mirror)
- [flare-foundation/flare-hardhat-starter](https://github.com/flare-foundation/flare-hardhat-starter) (cross-chain FDC deployment examples)
- [Coston2 Block Explorer](https://coston2-explorer.flare.network/)</result>
<usage>total_tokens: 70041
tool_uses: 76
duration_ms: 459558</usage>
</task-notification>
Full transcript available at: /tmp/claude-1000/-home-tom-dev-oasis-flare-poc/tasks/a66aa6b.output

---

the coston2 pk is funded for flare sapphire testnet and sepolia. you can create your own tx by sending yourself 0.0001 eth